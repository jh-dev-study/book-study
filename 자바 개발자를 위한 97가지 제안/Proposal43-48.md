## PROPOSAL 43 ~ PROPOSAL 48

### 43 자바의 불분명한 타입들 (벤 에번스)
  - 대체 널(null)이 무엇일까?
  - 자바를 처음 접하는 프로그래머는 널을 이해하는데 어려움을 겪는데, 다음 코드를 보면 그 내막을 알게 된다.

```java
String s = null;
Integer i = null;
Object o = null;
```

  - 따라서 null이라는 심볼은 값이어야 한다.
  - 'null이란 어떠한 참조 타입도 될 수 있는 특별한 리터럴'
  - 자바 언어 명세(JLS) 4.1절에서 다음과 같이 나와있다.

```html
자바는 특별한 null 타입을 지원한다.
이 타입은 이름을 갖지 않는 널을 표현한다.

null 타입은 이름이 없으므로 null 타입의 변수를 선언하거나 null 타입으로의 타입 변환은 불가능하다.
```

<br>

### 44 JVM은 멀티패러다임 플랫폼이다 (러셀 윈더)
  - 자바는 명령형 언어(Imperative Language)다.
  - 즉, 자바 프로그래머는 JVM이 무슨 동작을 언제 할 것인지 코드로 명령한다.
  - 하지만 컴퓨팅이란 것은 추상화의 구현에 대한 것이다.
  - 자바는 객체지향 언어로, 자바의 추상화는 객체, 메서드, 메서드 호출을 통한 **메시지의 전달** 등이다.
  - 자바를 이용해 점점 더 큰 시스템을 구현해오며 균열이 나타나기 시작했다.
  - 하지만 자바 8이 등장하면서 혁신적인 변화가 이루어졌다.
  - 메서드 참조, 람다 표현식, 인터페이스 기본 메서드(default method), 고차 함수, 암묵적 반복 등을 비롯해 많은 기능이 추가되었다.
  - 명령형 사고와 선언형(Declarative) 사고는 알고리즘을 표현하는 완전히 다른 방법이다.
  - 기본적으로 JVM은 웹서버 플러그인이었지만 서버 측 시스템을 구현하는 용도로 빠르게 전환되었다.
  - 자바 코드는 하드웨어에 독립적인 JVM 바이트코드로 컴파일되고 다시 인터프리터(interpreter)가 바이트코드를 실행했다.
  - 게다가 적시(JIT) 컴파일러 덕분에 전체 해석 모델을 JVM의 연산 모델로 바꾸지 않고도 훨씬 빠르게 실행할 수 있었다.
  - JVM을 최대한 활용하려면 문제를 해결할 올바른 프로그래밍 언어를 선택해야 한다.
  - 반드시 한 언어로 문제를 해결해야 한다는 뜻은 아니다.
  - JVM 덕분에 여러 언어(그루비, 스칼라, 코틀린 등)를 혼합해 문제를 해결할 수도 있다.

<br>

### 45 최신 동향을 파악하자 (트리샤 지)
  - 신입 첫 직장에서 애플릿(applet)이 사라지고 서블릿(servlet)이 대세가 되고 있음을 깨달었다.
  - 첫 이직 후 이제는 Vector를 사용하지 않고 ArrayList를 사용한다는 점을 깨달았다.
  - 이는 운이 좋았다.
  - 경력을 시작한 지 얼마 되지 않았음에도 필자가 참여한 자바 프로젝트에 영향을 미칠 수 있는 기술 변화를 아는 사람들을 주변에 둘 수 있었기 때문이다.
  - 사실 이는 시니어(senior) 팀 구성원의 역할이어야 했다.
  - 단순히 전달받은 사항을 지시하는 것이 아니라 문제를 해결하는 방법을 제시하고 나머지 팀이 함께 성장할 수 있도록 돕는 것 말이다.
  - 자바 프로그래머로 살아남기 위해서는 자바가 정체된 언어가 아니라는 점을 받아들여야 한다.
  - 자바는 단순히 버전만 올리는 것이 아니라 라이브러리, 프레임워크, 심지어 새로운 JVM 언어로 계속 발전하고 있다.
  - 현재 자바 버전에서 가능한 것과 앞으로 도입될 기능을 이해하는 것은 사용자에게 필요한 기능을 구현하는데 도움이 된다.
  - 즉 개발자로서 더욱 생산적이 된다는 뜻이다.
  - 자바는 이제 6개월마다 새 버전을 발표한다.
  - 계속해서 동향을 파악하면 여러분의 삶이 훨씬 더 편안해진다.

<br>

### 46 주석의 종류 (니콜리이 팔로그)
  - 자바 코드에 주석을 추가하는 상황을 생각해 보자.
  - /**, /*, // 중 어떤 키워드를 사용할 것인가?
  - 그리고 정확히 어느 위치에 이 주석을 추가할 것인가?
  - 단순 문법 문제를 떠나서 주석 의미에 따라 어떤 주석을 어디에 작성할 것인지를 결정해야 한다.
  
#### **계약은 자바독 주석으로 작성한다.**
  - 자바독 주석(/** ... */ 형식)은 클래스, 인터페이스, 필드, 메서드에만 사용하며 이들을 선언한 코드 바로 위에 작성한다.
  - 다음은 Map 인터페이스의 size() 메서드 자바독 주석이다.

```java
    /**
     * Returns the number of key-value mappings in this map.  If the
     * map contains more than {@code Integer.MAX_VALUE} elements, returns
     * {@code Integer.MAX_VALUE}.
     *
     * @return the number of key-value mappings in this map
     */
    int size();
```

  - 이 예시는 자바독 주석의 문법뿐만 아니라 그 의미도 보여준다.
  - 즉, 자바독 주석은 계약(contract)이다.
  - 이 주석으로 API 사용자에게 구현의 상세는 숨기고 타입이 추상화하는 동작을 설명한다.
  - 그와 동시에 이 메서드를 실제로 구현할 개발자에게도 어떤 동작을 구현해야 하는지를 설명한다.

#### **문맥은 블록 주석으로 작성한다.**
  - 블록(Block) 주석은 /* ... */ 로 둘러싼다.
  - 이 주석은 어느 자리에 작성해도 무관하며 개발 도구는 거의 이 주석을 무시한다.
  - 주로 클래스나 메서드의 시작 지점에서 그 구현 내용을 설명할 때 사용한다.
  - 좋은 예시는 HashMap 클래스에서 찾아볼 수 있다.

```java
/*
     * Implementation notes.
     *
     * This map usually acts as a binned (bucketed) hash table, but
     * when bins get too large, they are transformed into bins of
     * TreeNodes, each structured similarly to those in
     * java.util.TreeMap
     * [...]
*/
```

#### **이상한 점은 줄 단위 주석으로 작성한다.**
  - 줄 단위 주석은 //로 시작하므로 주석이 여러 줄인 경우 모든 줄에 반복해야 한다.
  - 주석의 위치에는 제약이 없지만, 보통 블록 바로 위에 작성한다.

#### 결론
  - 올바른 종류의 주석을 선택하자.
  - 엉뚱한 방법으로 주석을 사용하지 말자.
  - 코드가 볼썽사나우면 주석이라도 남기자!

<br>

### 47 은혜로운 flatMap (다니엘 이노호사)
  - 보편적인 프로그래머와 데이터 엔지니어는 모두 flatMap을 이해해야 한다.
  - map이나 filter와 마찬가지로 flatMap은 Stream<T>나 completableFuture<T> 처럼 '뭔가를 담는 컨테이너' 객체와 함께 사용할 수 있다.
  - 표준 라이브러리 이외로 눈을 돌려 보면 Observable<T>(RxJava)와 Flux<T>도 포함될 수 있다.
  - 여기서는 자바의 Stream<T>를 예로 들어보자.
  - map 메서드의 개념은 간단한데, 스트림이나 컬렉션 안의 모든 항목에 대해 지정한 함수를 실행하는 것이다.

```java
Stream.of(1, 2, 3, 4).map(x -> x * 2).collect(Collectors.toList());

// 결과: [2, 4, 6, 8]
```

  - 다음 코드는 어떻게 실행될까?

```java
Stream.of(1, 2, 3, 4)
    .map(x -> Stream.of(-x, x, x + 1))
    .collect(Collecotrs.toList());
    
// Stream 파이프라인의 List 객체가 리턴
```

  - 위 코드는 하나의 항목마다 여러 개의 스트림을 만들어내고 있다.
  - 이렇게 map 메서드에 여러 아이템을 리턴하는 함수를 적용해야 할 때 flatMap 메서드를 사용하면 된다.

```java
Stream.of(1, 2, 3, 4)
    .flatMap -> Stream.of(-x, x, x + 1))
    .collect(Collecotrs.toList());
    
// 결과: [-1, 1, 2, -2, 2, 3, -3, 3, 4, -4, 4, 5]
```

<br>

### 48 컬렉션을 제대로 이해하자 (니킬 나니바디카라)
  - 컬렉션은 모든 프로그래밍 언어에서 중요한 요소다.
  - 자바 언어는 JDK 1.2부터 컬렉션 프레임워크를 지원했다.
  - 많은 프로그래머가 ArrayList를 표준 컬렉션으로 사용하는데, 그 외에도 많은 유형의 컬렉션이 존재한다.
  - 컬렉션은 순서가 있는 것과 순서가 없는 것, 정렬된 것과 정렬되지 않는 것으로 나눌 수 있다.

#### List
  - List는 안정적인 인덱스를 기반으로 순서가 있는 컬렉션을 구현한 인터페이스다.
  - 리스트에는 중복된 값도 삽입할 수 있으며 아이템의 순회 순서를 예측할 수 있다.
  - List의 구현체로는 ArrayList, LinkedList가 있다.
  - 이 컬렉션의 contains 메서드는 특정 아이템을 찾을 수 있고, 리스트의 처음부터 아이템을 탐색하기 시작하므로 O(n) 연산이다.

#### Map
  - Map은 키와 값의 관계를 유지하며 유일한 키 값만 보관하는 인터페이스다.
  - 만일 맵에 같은 키와 다른 값을 추가하면 해당 키의 이전 값이 새 값으로 교체된다.
  - JDK는 HashMap, LinkedHashMap, TreeMap 등이 Map 인터페이스를 구현한다.
  - HashMap은 순서가 없는 반면, LinkedHashMap은 순서가 있다.
  - 두 클래스 모두 hashCode 메서드와 equals 메서드를 이용해 키의 유일성을 결정한다.
  - TreeMap은 정렬된 컬렉션이다. 즉 comparator나 Comparable 타입의 키를 이용해 아이템을 정렬한다.
  - TreeMap은 compareTo 메서드를 이용해 정렬 순서와 키의 유일성을 결정한다.
  - HashMap에서 키를 탐색하는 작업은 O(1) 연산이지만 값을 탐색하는 작업은 O(n) 연산이다.
    - 특정 아이템을 찾기 위한 containsKey와 containsValue 메서드를 제공한다.
    - containsKey메서드는 내부 해시테이블에서 키를 탐색한다.
    - containsValue 메서드는 컬렉션의 첫 아이템부터 모든 값을 탐색한다.

#### Set(Map과 연관)
  - Set은 유일한 아이템의 컬렉션을 정의하는 인터페이스다.(중복 X)
  - JDK에서는 키가 컬렉션의 아이템이며, 값은 널인 맵을 이용해 셋을 구현한다.
  - JDK는 HashSet(내부적으로 HashMap을 사용), LinkedHashSet(내부적으로 LinkedHashMap을 사용), TreeSet(내부적으로 TreeMap을 사용) 등을 지원한다.
  - Set 인터페이스는 특정 아이템을 탐색하기 위한 contains 메서드를 정의한다.
  - contains 메서드는 내부적으로 Map의 containsKey 메서드를 호출하므로 Set에서 아이템을 탐색하는 작업은 O(1) 연산이다.

#### 정리
  - 컬렉션은 소프트웨어 분야에서 매우 중요한 요소다.
  - 컬렉션을 효율적으로 사용하려면 각 컬렉션의 기능과 구현 방식, 그리고 최소한 아이템을 순회하는 방법 정도는 알아 둬야 한다.
  - 컬렉션은 그 활용 폭이 넓으면서도 코드의 기본적인 빌딩 블록이므로 관련 문서를 꼼꼼히 읽어보고 테스트를 작성하는 습관을 갖자.
