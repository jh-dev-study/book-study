## PROPOSAL 84 ~ PROPOSAL 96

### 84 마이크로서비스 아키텍처의 트레이드 오프 (케니 바타니)
  - 최적의 소프투웨어 아키텍처란 최소한의 비용으로 변경할 수 있는 극강의 유연성을 가진 것이다.
  - 여기서 비용이란, 인프라스트럭처의 운영 비용 외에 소프트웨어의 디자인과 구현을 입증하는 어떤 품질로 측정할 수 있는 것이다.
  - 마이크로서비스의 주요 문제 중 하나는 포괄적인 하나의 정의가 없다는 점이다.
  - 게다가 마이크로서비스는 서비스 아키텍처를 전달하기 위한 여러 제약에 기반을 둔 개념과 발상의 집합이다.
  - 마이크로서비스, 또는 여러분이 작성하는 소프트웨어의 일부는 선택의 기록이다.
  - 그리고 이 기록은 오늘 여러분이 새로운 선택을 하는 능력에 영향을 준다.
  - 마이크로서비르르 한 가지로 정의할 수는 없을지 몰라도 대부분 다음과 같은 공통점을 갖는다.
    - 독립적인 배포가 가능하다.
    - 비즈니스 역량을 중심으로 체계화된다.
    - 서비스별로 독립된 데이터베이스를 갖는다.
    - 한 팀이 한 애플리케이션을 담당한다.
    - API 우선 방식을 취한다.
    - 지속해서 전달된다.
  - 다음 내용은 마이크로서비스에 의존성을 추가하는 결정을 내릴 때 마주하게 될 트레이드 오프를 나열한 것이다.
    - 가용성: 내 시스템은 사용자에게 어느 정도의 가용성을 제공하는가?
    - 성능: 내 시스템의 전반적인 성능은 어느 정도인가?
    - 일관성: 내 시스템은 일관성과 관련해 어떤 것을 보장할 수 있는가?
    - 속도: 코드를 한 줄 바꿨을 때 프로덕션 환경에 얼마나 빨리 배포할 수 있는가?
    - 결합성(composability): 아키텍처와 코드베이스에서 복제하지 않고 공유할 수 있는 부분이 몇 %인가?
    - 연산: 부하가 피크(peak) 상태일 때 시스템의 연산 비용은 얼마인가?
    - 확장성: 부하의 피크가 계속 증가할 때 용량을 확장하기 위한 비용은 어느 정도인가?
    - 수익성: 내 팀에 개발자를 추가했을 때의 평균 감소 한계 수익은 얼마인가?
    - 파티션 내구성: 네트워크 파티션에서 장애나 응답 지연이 발생하면 내 애플리케이션이 연쇄 장애(cascading failure)의 영향을 받거나 유발할 것인가?
  - 각각의 질문은 서로 다른 질문과 연관이 있다는 것을 알게 될 것이다.

<br>

### 85 예외를 확인하지 말자(??) (케블린 헤니)
  - 자바 코드의 장점은 이해하기 쉽다는 점이고, 자바의 확인된 예외 모델도 이렇게 잘 정리된 개념 중 하나이다.
  - 확인된 예외(checked exception)란, 메서드 안에서 처리하지 않으면 반드시 메서드의 throws 절에 추가해야 하는 예외를 말한다.
  - throws 절에는 Throwable 인터페이스를 구현하는 클래스라면 어떤 것이든 나열할 수 있지만, 확인된 예외임에도 처리하지 않는(RuntimeException, Error 클래스를 상속하지 않는) 예외는 반드시 나열해야 한다.
  - 확인된 예외의 의도는 메서드가 성공적으로 실행될 때의 입력과 출력의 타입이 중요한 만큼, 메서드가 실패하는 경우도 예외의 타입으로 표현해서 두 가지 시나리오 모두 같은 수준의 타입 중요성을 갖도록 하자는 것이다.

```html
C#은 자바와 같은 예외 명세를 요구하지도 않고 허용하지도 않는다.
예외 명세는 프로그램의 크기가 작을 때는 개발자의 생산성과 코드의 품질을 모두 향상할 수 있지만, 대규모 소프트웨어 프로젝트에서는 그렇지 못했다.
오히려 생산성이 떨어지고 코드 품질의 향상은 극히 미미하거나 전혀 이루어지지 않았다.
```

  - 확인된 예외는 문법적으로 부담이 될 뿐이다.
  - 하지만 실질적인 문제는 단순히 프로그래머의 학습을 요구하거나 구문이 장황해지는 문제가 아니다.
  - 프레임워크 개발이나 확장 가능한 코드의 측면에서 볼 때 확인된 예외는 애당초 결함이었던 것이다.
  - 인터페이스는 안정적으로 정의하기도 어렵고 나중에 개선하기도 어렵다.
  - 다른 개발자가 자신의 애플리케이션에 여러분이 작성한 코드를 사용한다고 생각해 보자.
  - 이 개발자는 자신이 어떤 예외를 던질지 알 수도 있지만 여러분은 그 개발자가 어떤 예외를 던질지 알지도 못하고 알 필요도 없다.
  - 여러분의 코드는 그저 예외가 다른 개발자의 코드로 전달되어 그 애플리케이션 코드 예외 핸들러까지 도착하도록 하기만 하면 된다.
  - 제어의 역전(IoC)을 제대로 지원하려면 예외 투명성이 필요하다.

<br>

### 86 컨테이너로 통합 테스트의 숨겨진 가능성을 끌어내자 (케빈 위텍)
  - 대부분 자바 개발자는 어떤 형태로든 경력의 어느 한 시점에서 테스트 피라미드와 마주하게 된다.
  - 테스트 피라미드라는 비유는 다양하지만, 일반적으로는 상당한 양의 단위 테스트가 기반이 된다.
  - 그리고 그 위에 그보다 작은 양의 통합 테스트가 자리하며 꼭대기에는 더 작은 크기의 종단간 UI 테스트가 자리한다.
  - 이 도형은 서로 다른 테스트 클래스의 이상적인 최적의 비율을 제시한다.
  - 완전한 개발 환경을 갖춘 가상 머신을 사용하거나 혹은 가상 머신을 이용해 통합 테스트를 실행하는 데 필요한 외부 의존성을 실행하고 관리할 수 있다.
  - 하지만 대부분 가상 머신 구현체는 오버헤드를 가지고 있으므로 가상 머신을 사용한다는 것은 개발자의 워크스테이션에 상당한 부하와 리소스 소모를 유발한다.
  - 또한 테스트를 실행하기 위해 필요한 환경을 일시적으로 셋업하기 위한 가상 머신의 시작과 생성 시간은 너무 길다.
  - 반면, 사용자 친화적인 컨테이너 기술의 장점 덕분에 새로운 테스트 패러다임이 등장했다.
  - 내 생각에 우리가 달성하기 위해 노력해야 하는 목표는 테스트 환경의 셋업과 구성을 테스트 실행의 주요부분, 심지어 테스트 코드와 같은 수준으로 중요하게 취급하는 것이다.

<br>

### 87 퍼즈 테스트의 어마무시한 효과 (냇 프래이치)
  - 테스트 주도 개발(TDD)를 사용하든 사용하지 않든, 자동화 테스트를 작성하는 프로그래머라면 긍정적인 상황에 편향되는 어려움을 겪는다.
  - 즉 대부분의 프로그래머는 잘못된 입력이 주어졌을 때 소프트웨어가 얼마나 견고하게 동작하는지를 테스트하는 것 보다,
  - 유효한 입력이 주어졌을 때 소프트웨어가 올바르게 동작하는지를 테스트한다는 뜻이다.
  - 퍼즈 테스팅(Fuzz Testing)은 이미 존재하는 테스트 수트(suite)에 쉽게 부정적 테스트를 추가할 수 있는 엄청나게 효율적인 기법이다.
  - 예를 들어 광범위하게 사용되는 고객용 제품의 소프트웨어가 웹서비스에서 데이터를 로드하도록 확장하려 한다고 가정하자.
  - 견고한 네트워킹 코드를 신중히 작성하고, 긍정 & 부정적인 경우까지 모두 테스트한다 하더라도 퍼징은 소프트웨어가 예상치 못한 예외를 놀랄 정도로 많이 찾아낸다.
  - 퍼즈 테스트는 많은 임의의 입력을 생성해 테스트할 시스템에 전달한 후 소프트웨어가 허용할 수 있는 동작을 보이는지를 지속해서 확인한다.
  - 입력값을 생성하는 방법은 크게 두 가지다
    - 변형 기반 퍼저(mutation-based fuzzer)는 유효한 입력의 예시를 변경해서 유효하지 않은 테스트 입력을 생성한다.
    - 생성 기반 퍼저(generation-based fuzzer)는 문법 같은 형식화된 입력을 생성한다. 이 입력은 유효한 입력의 구조를 정의한다.
  - 전체 시스템에 임의의 입력 수천 개를 대입해 보는 것은 시간이 오래 걸린다.
  - 다시 말하지만 개발 과정에서 퍼즈 테스트를 적용한다면 시스템의 특정한 기능과 디자인에만 테스트를 적용할 수 있어 별개로 테스트가 가능하다.
  - 그런 후 퍼징을 이용해 테스트 단위의 올바른 동작과 타입을 확인한 후 시스템의 나머지 부분에서 올바르게 결합되는지만 확인화면 된다.
  - 퍼즈 테스팅은 이제 나의 테스트 주도 개발의 기본으로 자리잡고 있다.
  - 덕분에 결함을 없애고 더욱 결합적인(compositional) 시스템 디자인에 대한 가이드를 제시할 수 있게 되었다.
  - 자바와 코틀린 프로젝트에서 변형 기반 퍼즈 테스팅을 수행하기 위한 간단한 라이브러리는 깃허브(https://github.com/npryce/snodge) 에서 찾아볼 수 있다.

<br>

### 88 커버리지를 이용해 단위 테스트 개선하기 (에밀리 배쉬)
  - 테스트의 커버리지를 측정하기는 매우 쉽다.
  - IDE에서는 프로젝트를 실행하거나 디버그하는 버튼 바로 옆에 테스트를 실행하고 커버리지를 측정하는 버튼이 있다.
  - 커버리지 데이터를 얻기는 쉬운데 이 데이터를 활용하는 가장 좋은 방법은 무엇일까?
#### 새로운 코드를 작성할 때
  - 새로운 코드를 작성할 때 단위 테스트를 함께 작성해야 한다는 점에는 많은 사람이 동의한다.
  - 간단한 테스트 코드를 작성하고 약간의 프로덕션 코드를 추가해서 전체 기능을 테스트와 함께 구현해 나가는 방법이다.
  - 이런 방법으로 코드를 작성하면 가끔 테스트를 실행해 커버리지를 확인할 수 있음은 물론 새로운 코드를 작성할 때 잊지 않고 테스트를 작성할 수 있다.
  - 이 방법의 주요 문제점은 커버리지가 높아진 것에 만족한 나머지, 작업 중인 기능에서 중요한 부분을 구현하는 코드와 테스트를 놓치는 것을 간과하는 것이다.
  - 어쩌면 에러 처리를 잊었을 수 있고, 비즈니스 규칙 중 하나를 놓쳤을 수도 있다.
  - 만약 프로덕션 코드를 먼저 작성하지 않는다면 커버리지만으로는 해당 코드를 발견할 수 없다.
#### 다른 사람이 작성한 코드를 수정해야 할 때
  - 직접 작성하지 않은 코드인데다 관련된 테스트가 형편없거나 아예 없다면 수정에 애를 먹을 것이다.
  - 특히 코드의 동작을 이해하지 못하는 상황에서 수정해야 한다면 더욱 문제가 커진다.
  - 이런 상황에서는 테스트가 얼마나 잘 작성되었는지 그리고 어느 부분을 자신있게 리팩토링할 수 있는지 확인하는 방법 중 하나가 바로 테스트 커버리지다.
  - 또한 커버리지 데이터를 이용하면 새로운 테스트 케이스를 발견해 커버리지 지수를 높일 수 있다.
#### 팀의 일원으로 작업할 때
  - 팀은 명시적이든 묵시적이든 팀의 모든 구성원이 동의한 '표준' 이나 허용 행위가 있다.
  - 팀의 표준으로, 본인이 작성한 코드의 커버리지를 측정하고 리뷰 절차를 테스트하는 경우도 있다.
  - 커버리지는 복잡한 새 기능을 충분히 테스트하는지 확인할 방법이기도 하다.
  - 전체 코드베이스의 테스트 커버리지를 주기적으로 측정한다면 절대적 숫자보다는 트렌드에 집중하라고 권하고 싶다.
  - 커버리지는 단위 테스트를 개선하기 위한 것이며 단위 테스트는 리팩토링을 더 쉽게 하기 위한 것이다.
  - 커버리지 측정은 단위 테스트를 개선하고 여러분의 삶을 더 쉽게 만들 수 있는 아주 좋은 도구다.

<br>

### 89 사용자 정의 아이덴티티 애노테이션을 자유롭게 사용하자 (마크 리처드)
  - 자바의 애노테이션은 작성하기도 쉽고 사용도 쉬우며 매우 강력하다.
  - 원래 자바의 애노테이션은 관점 지향 프로그래밍(AOP, Aspect-Oriented Programming)을 편리하게 구현하기 위해 제공되었다.
  - AOP는 코드의 특정 지점에 행위를 주입해서 공통 행위를 코드로부터 분리하는 의도로 사용하던 기법이다.
  - 아이덴티티 애노테이션의 차이점은 어떤 기능도 갖지 않는다는 점이다.
  - 이 애노테이션은 단지 코드나 아키텍처의 어떤 관점을 다루고 분석하거나 문서화하기 위해 사용하는 프로그래밍적 정보를 제공할 뿐이다.
  - 아이덴티티 애노테이션을 사용하면 트랜잭션 경계나 도메인, 서브도메인을 특정하고 서비스의 분류, 프레임워크 코드의 표시 등 여러 방법으로 활용할 수 있다.
  - 예를 들어 기반 프레임워크의 클래스를 특정해서 변경 사항을 밀접하게 모니터링하거나 보호해야 하는 경우가 있다.
  - 이런 역할을 하는 애노테이션은 다음과 같다.

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Framework {}

@Framework
public class Logger {...}
```

  - 이 애노테이션은 아무런 동작을 하지 않는다. 아닌가?
  - 이 애노테이션은 이 클래스가 프레임워크와 관련한 클래스임을 표시한다.
  - 즉, 이 클래스를 변경하면 거의 모든 다른 클래스가 영향을 받는다는 뜻이다.
  - 다음 예제는 내가 정기적으로 사용하는 공통 아이덴티티 애노테이션의 목록이다(모두 클래스 수준에 지정한다)

```java
// 마이크로서비스의 진입쩜을 특정한다. 또한 다음에 설명하는 다른 서비스 설명 애노테이션을 위한 자리지정자(placeholder)로도 사용한다.
// 사용법: @ServiceEntryPoint
public @interface ServiceEntryPoint {}


// 분산 트랜잭션에 참여하는 서비스를 특정한다.
// Transaction 값은 여러 서비스로 확대된 트랜잭션의 목록을 나열한다.
// 이 애노테이션은 @ServiceEntryPoint 애노테이션이 지정된 클래스에 추가한다.
// 사용법: @Saga({Transaction.CANCEL_ORDER})
public @interface Sage {public Transaction[] value()...}


// 서비스가 속한 논리적 도메인(지불, 배송, 발송자 등)을 특정한다.
// 역시 @ServiceEntryPoint 애노테이션을 가진 클래스에 추가한다.
// 사용법: @@ServiceDomain(Domain.PAYMENT)
public @interface ServiceDomain {public Domain value()...}


// 서비스의 분류(classification)를 특정한다.
// Type 값은 서비스의 타입(분류)을 나열한다.
// 마찬가지로 @ServiceEntryPoint 애노테이션을 가진 클래스에 추가한다.
// 사용법: @ServiceType(Type.ORCHESTRATION)
public @interface ServiceType {public Type value()...}


// 애플리케이션 전체에 공통(공유되는) 코드를 가진 클래스를 특정한다.
// e.g) 포매터, 연산 클래스, 로깅, 보안 등
// 사용법: @SharedService
public @interface SharedService {}
```

  - 아이덴티티 애노테이션은 일종의 프로그래밍적 문서화다.
  - 앞으로는 주석 대신 아이덴티티 애노테이션을 사용하는 것을 고려하자.
  - 이 애노테이션을 자유롭게 활용해서 정보를 얻고 분석하고 서비스와 애플리케이션을 프로그래밍적으로 제어할 수 있다.

<br>

### 90 테스트를 이용해 더 나은 소프트웨어를 더 빨리 개발하자 (메릿 반 다이크)
  - 테스트를 이용하면 코드가 원하는 동작을 수행하는지 검증할 수 있다.
  - 또한 다른 기능에 영향을 주지 않고 새로운 기능을 추가, 변경, 제거할 수도 있다.
  - **그저 무엇을 테스트할지** 만 생각해봐도 소프트웨어를 사용할 다른 방법을 특정하고 아직 명확하지 않은 것을 발견하며 코드가 어떤 동작을 해야하는지를 더 잘 이해할 수 있게 된다.
  - 실제 기능을 구현하기에 앞서 **테스트를 어떻게 할 것인지**를 생각해 보면 애플리케이션의 테스트 가능성과 아키텍처를 더욱 개선할 수 있다.
  - 시스템의 아키텍처와 더불어 무엇을 테스트할지뿐만 아니라 어디서 테스트할지도 생각해 보자.
  - 비즈니스 로직은 최대한 그 로직을 작성한 곳과 가까운 곳에서 테스트해야 한다.
  - 단위 테스트는 작은 단위(메서드, 클래스)를 테스트하며 통합 테스트는 다른 컴포넌트간 통합을 테스트하고, 계약 테스트는 API가 깨지지 않도록 방지한다.
  - 특정 유형의 테스트 목표를 명심하고 그 목적에 맞는 도구를 사용하자!
  - 예컨대 성능 테스트는 개틀링(Gatling)이나 제이미터(JMeter)를, 계약 테스트는 스프링 클라우드 컨텍스트나 팩트(Pact)를, 변형 테스팅에는 PITest를 사용하는 것이다.
  - 하지만 이런 도구는 의도된 대로 사용해야 하기 때문에 이런 도구를 사용하는 것만으로는 충분하지 않다.
  - 테스트 자동화는 시스템의 일부이며 프로덕션 코드와 함께 유지보수해야 한다.
  - 테스트가 충분한 가치를 부여하도록 하고 테스트 실행과 유지보수에 드는 비용을 고려하자.
  - 테스트는 안정적이어야 하며 자신감을 향상할 수 있어야 한다.
  - 테스트를 믿을 수 없다면 수정하거나 차라리 지워버리자. 절대 무시해서는 안 된다.
  - 테스트를 무시해버리면 나중에 그 이유를 알기 위해 더 많은 시간을 낭비하게 될 것이다.
  - 실패하는 테스트는 실패 원인을 분석하느라 시간을 많이 소비하지 않아도 정확히 무엇이 잘못됐는지를 빠르게 알려줄 수 있어야 한다. 다음과 같은 사항을 의미한다.
    - 각 테스트는 한 가지만 테스트해야 한다.
    - 의미 있고 서술적인 이름을 사용한다.
    - 테스트 동작을 설명할 필요는 없고 왜 이 테스트를 수행하는지 설명하자.
    - Hamcrest 같은 매처(Matcher) 라이브러리는 기대한 결과와 실제 결과 사이의 차이점에 대한 상세 정보를 제공한다.
    - 실패한 적이 없는 테스트는 절대 신뢰하지 말자.
  - 테스트는 적절한 시점에 적절한 피드백을 제공해야 한다.
  - 그래서 코드 커밋부터 머지, 배포, 기능의 공개에 이르는 소프트웨어 수명 주기의 다음 단계에 자신감을 충분히 제공할 수 있어야 한다.
  - 테스트를 잘할수록 더 나은 소프트웨어를 더 빨리 전달할 수 있다.

<br>

### 91 테스트 코드에 객체지향 원리 적용하기 (앤지 존스)
  - 프로덕션 코드를 개발할 때와 같은 마음가짐으로 테스트 코드를 작성하는 것이 중요하다.
  - 테스트 코드를 구현할 때 적용할 수 있는 몇 가지 객체지향 원리를 살펴본다.

#### 캡슐화

#### 상속
  - 상속은 잘못 사용하면 안되지만 테스트 코드에서는 확실히 유용하다.

#### 다형성
  - 사용자 프로필 페이지가 사용하는 편의 메서드가 있다고 가정해보자.
  - 이 메서드는 프로필 페이지가 관리자용인지 일반 멤버용인지 알지 못한다.
  - 이 시점에서 디자인 결정에 마주하게 된다.
  - AdminProfilePage 와 MemberProfilePage는 모두 ProfilePage의 서브클래스이므로 슈퍼클래스(ProfilePage)를 리턴하는 편이 좋다.

```java
@test
void badge_exists_on_admin_profile() {
    var adminProfile = (AdminProfilePage) page.goToProfile("@admin");
    ...
}
```

#### 추상화
