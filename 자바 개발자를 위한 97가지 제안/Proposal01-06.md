## PROPOSAL 01 ~ PROPOSAL 06

### 01 자바만으로도 충분하다 (안드레스 노라스)
  - 자바는 훌륭한 언어이며 자바 클래스 라이브러리는 범용으로 설계되었다.
  - 애플리케이션이 하나의 함수를 배포 단위로 사용하는 서버리스(serverless) 아키텍처로 이동하면서 애플리케이션 프레임워크의 장점들은 희석되고 있음
  - 기술 및 아키텍처 관점의 문제들을 처리하는 시간은 줄어들고, 프로그램의 비즈니스적 기능에 프로그래밍 노력을 더 많이 들일 수 있게 되었기 때문
  - 브루스 조이스(Bruce Joyce)는 이렇게 표현했다.
    - 우리는 때때로 바퀴를 재발명 해야한다.
    - 많은 수의 바퀴가 필요하기보다는, 많은 수의 발명가가 필요하기 때문이다.
  - 종종 자바의 클래스 라이브러리가 조금 제한적이라는 것을 느끼고 다른 뭔가를 갈구할 때도 있을 것이다.
  - 그때는 필요한 라이브러리를 사용하면 된다.
  - 유행을 좇지 말자. 이제는 단순함의 시대다.

<br>

### 02 확인 테스트 (에밀리 배쉬)

```java 
assertEquals("", functionCall())
```

  - 보통 functionCall() 함수가 문자열을 리턴하는데 어떤 값을 리턴하는지 모를때
  - 리턴값을 보면 해당 함수의 리턴되는 문자열을 알 수 있다.
  - 처음 테스트는 실패하는데, 그 후 리턴값을 복사해서 첫 번째 파라미터로 복사해 넣는다.
  - 이제 테스트를 다시 실행하면 통과하는데, 이를 필자는 "확인 테스트(approval testing)" 라고 부른다.
  - 여기서 가장 중요한 단계는 일단 출력이 올바른지 확인 후 이를 기댓값으로 사용하는 부분이다.
  - 코드 작성자가 결과를 '확인'했으므로 그 값을 테스트에 사용해도 무방하다.
  - 확인 테스트는 다음과 같은 경우에 활용할 수 있다.
    - 변경해야 할 단위 테스트가 없는 코드
    - JSON이나 XML을 리턴하는 REST API와 함수
    - 복합 객체를 리턴하는 비즈니스 로직

<br>

### 03 AsciiDoc으로 자바독 확장하기 (제임스 엘리엇)
  - 자바독은 (간혹 매끄럽지 않거나 썩 훌륭하진 않지만) 풍부한 API 문서를 생성한다는 점에서 큰 이점이 있으며 이런 트렌드는 다른 많은 언어에도 퍼져 나갔다.
  - 제임스 고슬링의 토론 내용처럼 '자바독보다는 좋은 기술 문서 작성자가 훨씬 더 나은 결과물을 만들 수 있었기'에 초기는 보수적이었으나, 점차 보편적으로 사용할 수 있는 도구의 가치가 높아짐
  - 자바독이 제공하는 API 문서 외 따라하기, 가이드, 아키텍처, 상세한 이론 설명 등으로는 자바독만으로 충분히 문서화할 수 없다.
  - 이에 좋은 대안이 아스키독(AsciiDoc)이다.
  - [`자바독 참고`](https://github.com/jiaekim123/book-effective-java/blob/main/8%EC%9E%A5/56_%EA%B3%B5%EA%B0%9C%20API%20%EC%9A%94%EC%86%8C%EC%97%90%EB%8A%94%20%ED%95%AD%EC%83%81%20%EB%AC%B8%EC%84%9C%ED%99%94%20%EC%A3%BC%EC%84%9D%EC%9D%84%20%EC%9E%91%EC%84%B1%ED%95%98%EB%9D%BC_%EA%B9%80%EC%A7%80%EC%95%A0.md)
<br>

### 04 컨테이너를 제대로 이해하자 (데이비드 델라바시)
  - 컨테이너는 사실상 런타임 패키징 메커니즘의 표준이 되어가고 있다.
  - 적정 수준의 격리화, 향상된 자원 활용, 여러 환경으로 애플리케이션을 배포할 수 있는 기능 등 여러 장점을 제공하기 때문
  - 게다가 애플리케이션을 이식할 수 있는 컨테이너 안으로 패키징하므로 애플리케이션 사이의 의존성이나 애플리케이션의 기반 플랫폼에 대한 의존성을 줄여주기도 한다.

<br>

### 05 행위를 구현하는 것은 쉽지만 상태를 관리하는 것은 어렵다 (에드슨 야나가)
  - 필자가 객체지향 프로그래밍을 처음 배울 때 접한 개념이 다형성, 상속, 캡슐화임
  - 다형성과 상속은 너무 강조되나 캡슐화는 상대적으로 주목받지 못함
  - 캡슐화를 잘 활용하면 상태와 복잡도의 증가에 순응할 수 있음
    - 상태를 내면화해서 다른 컴포넌트로부터 숨기며,
    - 안전하게 디자인된 API로만 상태를 변경할 수 있게 하는 것이 캡슐화의 기본 개념이자 복잡한 정보 시스템을 디자인하고 구현하는 핵심
  - 최소 자바 세계에서는 제대로 캡슐화된 시스템 구축에 대한 몇 가지 권장 사례가 제대로 전파되지 않고 있다.
    - 별다른 기능이 없는 클래스의 자바빈(JavaBean) 속성은 그저 게터(getter), 세터(setter)로 내부 상태를 외부로 노출하는 것이 일반적이며,
    - 이미 대중화된 자바 엔터프라이즈 아키텍처는 대부분 모든 비즈니스 로직을 서비스 클래스에 구현
  - 행위(behavior)에 의해 발생한 버그를 특정짓는 것은 비교적 '쉬운'편이다.
    - 이런 경우는 자신의 역할을 제대로 하지 않는 코드가 있기 때문
  - 반면, 코드는 제대로 동작하는 것 같은데 여전히 버그가 존재하는 경우는 훨씬 복잡하다.
    - 모순된 상태로 발생하는 버그
    - Null 값이 되어서는 안되는 속성의 값이 Null을 갖게 되어 발생하는 NullPointerException 예외
    - 반드시 양수여야 하는데 음수의 값을 갖게 되는 경우 등
  - 유효성 검사(validation) 프레임워크를 이용해 사용자가 제공하는 입력값은 확인하지만 모든 코드가 '내부 상태의 값만 변경하는' 세터를 호출할 수 있다.
  - 이러한 문제는 어떻게 해결할 수 있을까?
  - **불변성(immutability)이 그 해법 중 하나다.**
    - 객체가 불변임을 보장할 수 있고 객체를 생성하는 시점에 상태의 무결성을 검사할 수 있다면, 시스템은 절대 모순된 상태가 되지 않을 것이다.
    - 하지만 자바의 특성상 불변성을 제대로 다루지 못한다면 적어도 **가변성**을 최소화해야 한다.
    - 올바르게 구현한 팩토리 메서드와 빌더(Builder) 패턴을 이용하면 가변 상태를 최소화할 수 있다.
  - 따라서, 세터를 자동으로 생성하지 말자. 대신 세터에 대해 오래 생각해보자.
  - 세터를 추가해야 한다면, 사용 후 내부 상태를 보호하고 검증하기 위한 **변질 방지 계층**을 사용하는 것을 고려하자.

<br>

### 06 JMH로 조금 더 쉽게 벤치마킹해 보자 (마이클 헝거)
  - JVM에서의 벤치마킹, 특히 마이크로벤치마킹은 어렵다.
  - 그저 메서드 호출이나 루프가 나노초 내에 완료된다고 해서 끝낼 수 있는 것이 아니기 때문이다.
  - 웜업(warm-up), 핫스폿 컴파일레이션(HotSpot compilation), 인라이닝(Inlining), 데드코드(dead code)제거, 멀티스레딩, 측정치의 일관성 같은 코드 최적화도 고려해야 한다.
  - JMH는 올바른 마이크로벤치마크를 작성하기 위한 강력한 도구다.
  - 같은 환경에서 실행하면 결과도 비교할 수 있으므로 벤치마크 결과를 해석하는 주된 방법으로 사용해야 한다.
  - 게다가 안정적이며 반복적인 결과를 제공하므로 프로파일링 목적으로도 사용할 수 있다.
  - [`참고`](https://javabom.tistory.com/75)

<br>

### References
  - [`자바 개발자를 위한 97가지 제안`](http://www.yes24.com/Product/Goods/96036230)
